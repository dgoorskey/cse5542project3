<!DOCTYPE html>
<html>
    <head>
       <title>demo</title>

        <link rel="stylesheet" href="style.css">

        <script id="vertexshader" type="x-shader/x-vertex">
            attribute vec3 va_position;
            uniform vec2 vu_canvassize; // w h, size of canvas
            uniform mat4 vu_transform;
            uniform mat4 vu_projection;

            void main(void) {
                vec4 pos = vec4(va_position, 1); // pos is in world coordinates (intended to be equivalent to pixel coordinates)

                // [ n/r 0   0            0
                //   0   n/t 0            0
                //   0   0   -(f+n)/(f-n) -2fn/(f-n)
                //   0   0   -1           1          ]
                //
                // n: near plane distance (positive)
                // f: far plane distance (positive)
                // n: cot( fov_y / 2 )
                // (see http://www.songho.ca/opengl/gl_projectionmatrix.html)

                //pos = vec4((vu_transform * vec4(pos.xyz, 1)).xyz, 1); // apply transform in world coordinate space
                pos = vu_transform * pos;
                //pos.xy += vu_canvassize * vec2(-0.5, -0.5); // translate world coordinates so the center of the screen is (0, 0). (e.g. x=400 on an 800px wide screen is now x=0)
                pos.xy /= vu_canvassize * vec2(0.5, 0.5);   // scale coordinates to map everything to [-1, 1]. (e.g. x=0 on an 800px wide screen is now x=-1, whereas x=800 is now x=1)
                //pos.y *= -1.0; // flip the y coordinate system for sanity
                pos.z *= -1.0; // flip the z coordinate system for sanity

                // perspective divide
                // see https://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html
                pos.z /= 200.0;
                pos.w = pos.z * 1.0 + 1.01; // opengl automatically normalizes gl_Position wrt w

                gl_Position = pos;

                gl_PointSize = 3.0;
            }
        </script>
        <script id="fragmentshader" type="x-shader/x-fragment" src="fshader.glsl">
            precision mediump float; // see https://webglfundamentals.org/webgl/lessons/webgl-fundamentals.html

            uniform vec4 fu_color;
            void main(void) {
                gl_FragColor = fu_color;
            }
        </script>

        <script src="color.js"></script>
        <script src="vec3.js"></script>
        <script src="vec4.js"></script>
        <script src="mat2.js"></script>
        <script src="mat3.js"></script>
        <script src="mat4.js"></script>
        <script src="transform.js"></script>
        <script src="node.js"></script>
        <script src="gl.js"></script>
        <script src="engine.js"></script>

        <script>
            let mat3 = mat3_new(
                3, 0, 2,
                2, 0, -2,
                0, 1, 1
            );
            console.log(mat3);
            console.log(mat3_inverse(mat3));
            let mat4 = mat4_new(
                1, 2, 5, 3,
                2, 2, 4, 4,
                3, 4, 5, 6,
                0, 0, 0, 1
            );
            console.log(mat4);
            console.log(mat4_inverse(mat4));
        </script>

        <script>
            /*
            function main() {
                let engine = engine_new("canvas", "vertexshader", "fragmentshader");
                engine_run(engine);
            }
            */
        </script>
    </head>
    <body onload="">
        <canvas id="canvas" tabindex="0" autofocus></canvas>
    </body>
</html>
